-- null
DEPTH = 4096;
WIDTH = 32;

ADDRESS_RADIX = DEC;
DATA_RADIX = BIN;

CONTENT
BEGIN
    -- addi $1,  $0,   7        # $1 = 7
0000 : 00101000010000000000000000000111;
    -- addi $2,  $0,  13        # $2 = 13
0001 : 00101000100000000000000000001101;
    -- addi $3,  $0,  -5        # $3 = -5 (sign-extended)
0002 : 00101000110000011111111111111011;
    -- addi $5,  $0, 100        # $5 = 100  (base for memory tests)
0003 : 00101001010000000000000001100100;
    -- addi $12, $0,   1        # $12 = 1   (for shifts)
0004 : 00101011000000000000000000000001;
    -- add  $6,  $1,  $2        # $6 = $1 + $2  => 20
0005 : 00000001100000100010000000000000;
    -- sub  $7,  $2,  $1        # $7 = $2 - $1  => 6
0006 : 00000001110001000001000000000100;
    -- and  $8,  $1,  $2        # $8 = 7 & 13
0007 : 00000010000000100010000000001000;
    -- or   $9,  $1,  $2        # $9 = 7 | 13
0008 : 00000010010000100010000000001100;
    -- addi $10, $1,  -3        # $10 = 7 + (-3) => 4
0009 : 00101010100000111111111111111101;
    -- addi $11, $3,   1        # $11 = -5 + 1 => -4
0010 : 00101010110001100000000000000001;
    -- sll  $13, $12,  4        # $13 = 1 << 4 => 16
0011 : 00000011010110000000001000010000;
    -- addi $14, $0, -16        # $14 = -16
0012 : 00101011100000011111111111110000;
    -- sra  $15, $14,  2        # $15 = -16 >>> 2 => -4
0013 : 00000011110111000000000100010100;
    -- sw   $6,  3($5)          # MEM[103] = $6 (20)
0014 : 00111001100010100000000000000011;
    -- lw   $7,  3($5)          # $7 = MEM[103] => overwrites $7 with 20
0015 : 01000001110010100000000000000011;
    -- addi $20, $0, 1          # $20 = 1
0016 : 00101101000000000000000000000001;
    -- sll  $20, $20, 30        # $20 = 1 << 30 = 0x40000000
0017 : 00000101001010000000111100010000;
    -- add  $21, $20, $20       # $21 = $20 + $20 => 0x80000000 (signed overflow)
0018 : 00000101011010010100000000000000;
    -- addi $28, $0, 32767      # $28 = 32767
0019 : 00101111000000000111111111111111;
    -- sll  $28, $28, 16        # $28 <<= 16 => 0x7FFF0000
0020 : 00000111001110000000100000010000;
    -- addi $28, $28, 65535     # -> 0x7FFFFFFF (INT_MAX)
0021 : 00101111001110001111111111111111;
    -- addi $28, $28, 1         # overflow -> $28 becomes 0x80000000 and rstatus=2 in $30
0022 : 00101111001110000000000000000001;
    -- addi $29, $0, 1          # $29 = 1
0023 : 00101111010000000000000000000001;
    -- sll  $29, $29, 31        # $29 = 1 << 31 = 0x80000000 (signed MIN)
0024 : 00000111011110100000111110010000;
    -- sub  $23, $29, $12       # causes overflow -> rstatus = 3 in $30
0025 : 00000101111110101100000000000100;
    -- addi $16, $1, 4          # $16 = $1 + 4   
0026 : 00101100000000100000000000000100;
    -- addi $17, $0, 999        # $17 = 999      
0027 : 00101100010000000000001111100111;
    -- sw   $17, 11($5)         # MEM[$5 + 11] = 999
0028 : 00111100010010100000000000001011;
    -- lw   $18, 11($5)         # $18 = MEM[$5 + 11] => 999
0029 : 01000100100010100000000000001011;
    -- add  $19, $18, $6        # $19 = $18 + $6  => 999 + 20 = 1019
0030 : 00000100111001000110000000000000;
    -- addi $24, $0, 65535       # $24 = 65535
0031 : 00101110000000001111111111111111;
    -- addi $25, $0, -65536      # $25 = -65536
0032 : 00101110010000010000000000000000;
    -- sw   $1, 0($5)            # MEM[$5 + 0] = $1 (7)
0033 : 00111000010010100000000000000000;
    -- sw   $1, -1($5)           # MEM[$5 - 1] = $1 (tests negative offset)
0034 : 00111000010010111111111111111111;
    -- lw   $26, 0($5)           # $26 = MEM[$5 + 0] -> should be 7
0035 : 01000110100010100000000000000000;
    -- lw   $27, -1($5)          # $27 = MEM[$5 - 1] -> should be 7
0036 : 01000110110010111111111111111111;
    -- sw   $3, 5($5)            # MEM[$5 + 5] = $3 (-5)
0037 : 00111000110010100000000000000101;
    -- lw   $14, 5($5)           # $14 = MEM[$5 + 5] -> should be -5
0038 : 01000011100010100000000000000101;
    -- addi $2, $0, 21           # $2 = 21
0039 : 00101000100000000000000000010101;
    -- sw   $2, 7($5)            # MEM[$5 + 7] = $2 (21)
0040 : 00111000100010100000000000000111;
    -- lw   $8, 7($5)            # $8 = 21
0041 : 01000010000010100000000000000111;
    -- sw   $6, 1($5)            # MEM[$5 + 1] = 20
0042 : 00111001100010100000000000000001;
    -- sw   $9, 2($5)            # MEM[$5 + 2] = ($9 from earlier)
0043 : 00111010010010100000000000000010;
    -- lw   $21, 1($5)           # $21 = 20
0044 : 01000101010010100000000000000001;
    -- lw   $22, 2($5)           # $22 = $9
0045 : 01000101100010100000000000000010;
    -- addi $31, $0, 32767       # $31 = 32767
0046 : 00101111110000000111111111111111;
    -- sll  $31, $31, 16         # $31 <<=16 -> 0x7FFF0000
0047 : 00000111111111100000100000010000;
    -- addi $31, $31, 65535      # $31 = 0x7FFFFFFF
0048 : 00101111111111101111111111111111;
    -- addi $31, $31, 1          # overflow -> $30 should be set to 2
0049 : 00101111111111100000000000000001;
    -- addi $1,  $0,  7         # $1 = 7
0050 : 00101000010000000000000000000111;
    -- addi $2,  $0,  8         # $2 = 8
0051 : 00101000100000000000000000001000;
    -- bne  $1,  $2, branch_bne_pass
0052 : 00010000010001000000000000000001;
    -- addi $30, $0, 1          # should be skipped if BNE works
0053 : 00101111100000000000000000000001;
    -- branch_bne_pass: nop
0054 : 00000000000000000000000000000000;
    -- addi $31, $0, 2          # marker for BNE path taken
0055 : 00101111110000000000000000000010;
    -- addi $3,  $0,  -2        # $3 = -2
0056 : 00101000110000011111111111111110;
    -- addi $4,  $0,   3        # $4 = 3
0057 : 00101001000000000000000000000011;
    -- blt  $3,  $4, branch_blt_pass
0058 : 00110000110010000000000000000001;
    -- addi $29, $0, 3          # should be skipped if BLT works
0059 : 00101111010000000000000000000011;
    -- branch_blt_pass: nop
0060 : 00000000000000000000000000000000;
    -- addi $28, $0, 4          # marker for BLT path taken
0061 : 00101111000000000000000000000100;
    -- setx  42                 # $rstatus = 42
0062 : 10101000000000000000000000101010;
    -- bex   SKIP_BEX           # PC = SKIP_BEX
0063 : 10110000000000000000000001000001;
    -- addi  $1, $0, 99         # skipped if bex worked
0064 : 00101000010000000000000001100011;
    -- SKIP_BEX: nop
0065 : 00000000000000000000000000000000;
    -- addi  $1, $0, 11         # $1 = 11
0066 : 00101000010000000000000000001011;
    -- jal CALLER_FUNC          # $31 = PC+1
0067 : 00011000000000000000000001001100;
    -- addi  $5, $0, 0          # Return point. $5=0 (temp)
0068 : 00101001010000000000000000000000;
    -- j     AFTER_STUB
0069 : 00001000000000000000000001001001;
    -- STUB: nop
0070 : 00000000000000000000000000000000;
    -- addi $5, $0, 99          # Skipped
0071 : 00101001010000000000000001100011;
    -- j     CONTINUE_SKIPPED   # Skipped
0072 : 00001000000000000000000001010010;
    -- AFTER_STUB: nop
0073 : 00000000000000000000000000000000;
    -- addi $6, $0, 6           # $6 = 6
0074 : 00101001100000000000000000000110;
    -- j     CONTINUE_SKIPPED   
0075 : 00001000000000000000000001010010;
    -- CALLER_FUNC: nop
0076 : 00000000000000000000000000000000;
    -- addi $2, $0, 2           # $2 = 2
0077 : 00101000100000000000000000000010;
    -- addi $3, $0, -5          # $3 = -5
0078 : 00101000110000011111111111111011;
    -- addi $4, $0, 4           # $4 = 4
0079 : 00101001000000000000000000000100;
    -- addi $7, $0, 77          # $7 = 77
0080 : 00101001110000000000000001001101;
    -- jr   $31                 # Return
0081 : 00100111110000000000000000000000;
    -- CONTINUE_SKIPPED: nop
0082 : 00000000000000000000000000000000;
    -- j     J_TARGET
0083 : 00001000000000000000000001010101;
    -- addi  $8, $0, 99         # skipped
0084 : 00101010000000000000000001100011;
    -- J_TARGET: nop
0085 : 00000000000000000000000000000000;
    -- addi  $8, $0, 8          # $8 = 8
0086 : 00101010000000000000000000001000;
    -- setx 0
0087 : 10101000000000000000000000000000;
    -- bex  BEX_FAIL_PATH       # Should NOT jump
0088 : 10110000000000000000000001011011;
    -- addi $9, $0, 99          # $9 = 99 (Correct)
0089 : 00101010010000000000000001100011;
    -- j    done                # Skip failure case
0090 : 00001000000000000000000001011101;
    -- BEX_FAIL_PATH: nop
0091 : 00000000000000000000000000000000;
    -- addi $9, $0, 12345       # Marker for failure
0092 : 00101010010000000011000000111001;
    -- done: nop
0093 : 00000000000000000000000000000000;
    -- j done                   # Infinite loop to terminate cleanly
0094 : 00001000000000000000000001011101;
    -- nop
0095 : 00000000000000000000000000000000;
[0096 .. 4095] : 00000000000000000000000000000000;
END;
